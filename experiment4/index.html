<!DOCTYPE html>
<html>
<head>
	<!-- This title is used for tabs and bookmarks -->
	<title>Experiment 4 - Images/Videos/Sound Art</title>

	<!-- Use UTF character set, a good idea with any webpage -->
	<meta charset="UTF-8" />
	<!-- Set viewport so page remains consistently scaled w narrow devices -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<!-- Include CSS file, including a site-wide CSS and for this particular page -->
	<link rel="stylesheet" type="text/css" href="../css/site.css">
	<link rel="stylesheet" type="text/css" href="css/style.css">

	<!-- Load jQuery library -->
	<script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
	<!-- Load p5.js library -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.js"></script>

	<!-- Link to javascript files - DEFER waits until all elements are rendered -->
	<!-- Use me for a JavaScript OOP Project -->
	<script type="text/javascript" src="./js/project.js" DEFER></script>
	<!-- Use me for a p5.js project -->
	<script type="text/javascript" src="./js/sketch.js" DEFER></script>
</head>
<body>
	<!-- Style this page by changing the CSS in ../css/site.css or css/experiment.css -->
	<main id="content">
		<section>
			<h1>Experiment 4 - Images/Videos/Sound Art</h1>
			<div class="minor-section">
				<h2>Imitate</h2>
				<p>My first attempt at this experiment was to try and understand how the video capturing worked. I took examples from my section as well as the slides and found that using p5.js made it really simple to capture real-time videos.
				</p>
				<p>Code: var capture;
					function setup() {
					  createCanvas(640, 480);
					  capture = createCapture(VIDEO);
					  capture.size(640,480);
					  imgCache = createGraphics(640,480)
					  imgCache.translate(640,0)
					  imgCache.scale(-1,1)
					  capture.hide();
					 
					}
				   
					function draw() {
					  background(220);
					  imgCache.image(capture,0,0)
					}
				</p>
				<p>I then began this experiment by copying one of the examples from class, specifically the example by Che-Yu Wu. I found the code very interesting because it took a video from the camera, and replaced each pixel with Chinese characters. 
				</p>
				<p>var capture;
					var radius = 20;
					var imgCache
						let overAllTexture
					function setup() {
						createCanvas(640,480);
						capture = createCapture(VIDEO);
						capture.size(640,480);
						imgCache = createGraphics(640,480)
						imgCache.translate(640,0)
						imgCache.scale(-1,1)
						// println(capture.height,capture.height)
						// background(100);
						rectMode(CENTER)
						capture.hide()
					   
					   
						overAllTexture=createGraphics(width,height)
						overAllTexture.loadPixels()
						// noStroke()
						for(var i=0;i<width+50;i++){
							for(var o=0;o<height+50;o++){
								overAllTexture.set(i,o,color(100,noise(i/3,o/3,i*o/50)*random([0,50,100])))
							}
						}
						overAllTexture.updatePixels()
					   
					}
					let mode = 1
					function draw() {
						// loadImage(capture)
						background(0);
						imgCache.image(capture,0,0)
					   
						push()
							noStroke()
							scale(1)
							radius = max(mouseX,0)/10+20
							for(var y=0;y<imgCache.height;y+=radius){
								for(var x=0;x<imgCache.width;x+=radius){
									var pixel = imgCache.get(x,y)
									var r = pixel[0]
									var g = pixel[1]
									var b = pixel[2]
					
					
									let bk = (r+g+b)/3
									let bkI = 10-int(bk/25.5)
								   
									if (mode==1){
										let txt = "ä¸€äºŒä¸‰å¤©å››äº”ç”°é›»é¾é¾•é¾˜"
										fill(r+50,g+50,b+50)
										textSize(radius)
										textStyle(BOLD)
										text(txt[bkI],x,y)
									}else if (mode==2){
										ellipse(x,y,radius/3+b/15,radius/3+b/15)
									}else if (mode==3){
										push()
											translate(x,y)
											rotate(b/20)
											colorMode(HSB)
											fill(r,100,100)
											// strokeWeight(3)
											// noFill()
											rect(0,0,radius/2.5+r/20,radius/2.5+r/20)
											fill(0)
											ellipse(0,0,5)
										pop()
									}
									// fill(0)
									// rect(x,y,radius/10+b/10-10,radius/10+b/10-20)
								}  
							}
						pop()
					   
						push()
							blendMode(MULTIPLY)
							image(overAllTexture,0,0)
						pop()
					   
					   
						// ellipse(mouseX, mouseY, 20, 20);
					}
					
					
					function keyPressed(){
						if (key=="1"){
							mode=1
						}
						if (key=="2"){
							mode = 2
						}
						if (key=="3"){
							mode = 3
						}
					}
					function mousePressed(){
						mode++
						if (mode>3){
							mode=1
						}
					}
					</p>
			</div>

			<div class="minor-section">
				<h2>Integrate</h2>
				<p>After messing around with Che-Yuâ€™s example, I found some things that I wanted to change. One of my biggest gripes was that the ratios of the video would change with the movement of the mouse. It wasnâ€™t the biggest deal, but it also felt needless so I decided to take it out. Another thing I messed around with was changing what characters are used for the pixels. What I found was that thin and small characters werenâ€™t very good because it left a long empty space and the formed image looked more abstract. I then tried using ellipses instead of text for the pixels.
				</p>
				<p>Code: for(var y=0;y<imgCache.height;y+=radius){
					for(var x=0;x<imgCache.width;x+=radius){
						var pixel = imgCache.get(x,y)
						var r = pixel[0]
						var g = pixel[1]
						var b = pixel[2]
			
			
						let bk = (r+g+b)/3
						let bkI = 10-int(bk/25.5)
						let txt = "ã“ã‚“ã«ã¡ã¯åã®è¨€è‘‰/"
						fill(r+50,g+50,b+50)
						textSize(radius)
						textStyle(BOLD)
						//text(txt[bkI],x,y)
					  ellipse(x,y,radius/3+b/15,radius/3+b/15)
			</p>
			</div>

			<div class="minor-section">
				<h2>Innovate</h2>
				<p>After understanding how the pixelization worked, I wanted to add back interactivity as well as images. So my idea was to have a second mode, activated by a mouse click which would lead to another canvas involving images. I wanted to put these images through the same video filter so I began by trying it with a Cat.png. 
				</p>
				<p>imgCache.image(img,width/2,height/2);
				</p>
				<p>After I got the cat picture working through the filter, my next step was to add a way to interact with the cat. My idea for this was to have the cat move in conjunction with the mouse, similar to the feature that I had removed earlier, but instead of zooming in on the cat it would move it around. After getting the cat on screen, I realized that I could achieve an effect where it looked like the cat could be chased or chasing something using mouse movement. So I added an additional dog picture into my experiment and adjusted its speed so that both didnâ€™t move at the same speeds.</p>
				<p>var img;
					var mode = 0;
					function preload(){
					  img = loadImage("Cat.jpg");
					  img2 = loadImage("Dog.jpg");
					}
					
					
					var capture;
					var imgCache
					let overAllTexture
					function setup() {
					  createCanvas(640, 480);
					  capture = createCapture(VIDEO);
					  capture.size(640,480);
					  imgCache = createGraphics(640,480)
					  imgCache.translate(640,0)
					  imgCache.scale(-1,1)
					  capture.hide();
					 
					  overAllTexture=createGraphics(width,height)
					  overAllTexture.loadPixels()
						// noStroke()
						for(var i=0;i<width+50;i++){
							for(var o=0;o<height+50;o++){
					  overAllTexture.set(i,o,color(100,noise(i/3,o/3,i*o/50)*random([0,50,100])))
							}
						}
						overAllTexture.updatePixels()
					  radius = 10;
					 
					}
					
					
					function draw() {
					  background(220);
					  if(mode == 0){
						imgCache.image(capture,0,0);
					  }
					  else if(mode == 1){
						imgCache.clear();
						imgCache.image(img,mouseX,mouseY);  
						imgCache.image(img2,(mouseX+500)/2,mouseY);
					  }
					  push()
					  noStroke()
					  scale(1)
							for(var y=0;y<imgCache.height;y+=radius){
								for(var x=0;x<imgCache.width;x+=radius){
									var pixel = imgCache.get(x,y)
									var r = pixel[0]
									var g = pixel[1]
									var b = pixel[2]
					
					
									let bk = (r+g+b)/3
									let bkI = 10-int(bk/25.5)
									let txt = "ã“ã‚“ã«ã¡ã¯åã®è¨€è‘‰ðŸ˜€"
									fill(r+50,g+50,b+50)
									textSize(radius)
									textStyle(BOLD)
									text(txt[bkI],x,y)
								  //ellipse(x,y,radius/3+b/15,radius/3+b/15)
									}
							}
					  pop()
					   
						push()
							blendMode(MULTIPLY);
							image(overAllTexture,0,0);
						pop()
					}
					
					
					function mousePressed(){
					  if(mode == 1){
						mode = 0;
					  }
					  else{
						mode += 1;
					  }
					}
				</p>
			</div>

			<div class="minor-section">
				<h2>Reflection</h2>
				<p>I had another struggle with creativity this time due to not quite understanding how the images and videos worked. I had no idea how to implement the ideas that I might have had or I struggled to come up with an idea outright. This problem got significantly better when I decided to go into the examples and replicate them for myself. After understanding a little more about videos and images, I started coming up with simple ideas. I added these simple ideas together to create something that I hoped would look more complex. I thoroughly enjoyed learning about how the videos worked, especially when I actually got things working. My biggest struggle was figuring out what to do after I learned the basics of videos and images. What made it harder was the lack of direction in the assignment so I had to determine what was considered high effort.</p>
			</div>

			<div class="minor-section">
				<h2>Results</h2>
				<div id="canvas-container">
					<!-- canvas will be added here -->
				</div>
			</div>
		</section>
		<nav id="links">
			<!-- Put links to other pages (including the homepage) here. -->
			<li><a href="../index.html">Home</a></li>
			<li><a href="../experiment1/index.html">Experiment 1</a></li>
			<li><a href="../experiment2/index.html">Experiment 2</a></li>
			<li><a href="../experiment3/index.html">Experiment 3</a></li>
		</nav>
	</main>
</body>
</html>
